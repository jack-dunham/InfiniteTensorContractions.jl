abstract type AbstractBoundaryAlgorithm <: AbstractContractionAlgorithm end
abstract type AbstractBoundary end
abstract type AbstractBoundaryState{B<:AbstractBoundary} end

@with_kw struct BoundaryAlgorithm{B<:AbstractBoundary} <: AbstractBoundaryAlgorithm
    alg::Type{B}
    bonddim::Int
    verbosity::Int = 0
    maxiter::Int = 100
    tol::Float64 = 1e-12
end

function similarboundary(
    ::Type{Alg}, alg::AbstractBoundaryAlgorithm
) where {Alg<:AbstractBoundary}
    return BoundaryAlgorithm(Alg, alg.bonddim, alg.verbosity, alg.maxiter, alg.tol)
end

@doc raw"""
    BoundaryState{B<:AbstractBoundary} <: AbstractBoundaryState{B}

A struct representing the state of boundary algorithm of type `B`. The paramater `B`
can be one of `VUMPS`, `CTMRG`, `FPCM`, `FPCM_CTMRG`, or a user-defined algorithm. 

# Fields
- `data::B`: the tensors that compose the boundary, in addition to algorithm specific 
    data
- `mpo::InfMPO`: the matrix product operator whos boundary tensors are stored in `data`
- `initial::Alg`: the tensors used as the starting point of the algorithm
- `info::ConvergenceInfo`: information about the covergence progress of the algorithm
- `param::BoundaryParameters`: the paramaters used in the algorithm
"""
struct BoundaryState{B} <: AbstractBoundaryState{B}
    initial::B
    bulk
    alg::BoundaryAlgorithm{B}
    tensors::B
    info::ConvergenceInfo
end

@doc raw"""
    inittensors(f, T, alg::BoundaryAlgorithm)

Initialise the boundary tensors compatible with lattice `T` for use in boundary algorithm
`alg`.
"""
function inittensors(f, T, alg::BoundaryAlgorithm) end

# @doc raw"""
# Initilise a new `alg` boundary algorithm state for contracting the infinite lattice
# generated by `T` using boundary tensors generated from the function `f`. The callable 
# `f` should be a callable compatible with the `TensorMap` object. Alternatively, initialise 
# a new algorithm state with initial boundary given by `B`.
# """
# function initstate(f, T, alg::BoundaryAlgorithm)
#     return boundary = inittensors(f, T, alg)
# end

(alg::BoundaryAlgorithm)(bulk) = alg(rand, bulk)
function (alg::BoundaryAlgorithm)(f, bulk)
    boundary = inittensors(f, bulk, alg)
    return alg(boundary, bulk)
end
function (alg::BoundaryAlgorithm)(boundary::AbstractBoundary, bulk)
    return BoundaryState(boundary, bulk, alg, boundary, ConvergenceInfo())
end

@doc raw"""
    calculate(b::BoundaryState)

Calculate the boundary tensors.
"""
calculate(state::BoundaryState) = calculate!(deepcopy(state))
function calculate!(state::BoundaryState)
    alg = state.alg
    # Immutable parameters
    verbosity = alg.verbosity
    maxiter = alg.maxiter
    tol = alg.tol
    bonddim = alg.bonddim
    # Mutating parameters
    info = state.info
    error = info.error
    iterations = info.iterations

    # Remove any wrappers, converting tensors to appropraite forms.
    bulk = detrace(state.bulk)

    info.error, info.iterations = calculate!(
        state.tensors, bulk; bonddim=bonddim, verbosity=verbosity, tol=tol, maxiter=maxiter
    )

    info.error > tol ? info.converged = false : info.converged = true

    info.finished = true

    return state
end

function similarboundary(
    ::Type{Alg}, state::AbstractBoundaryState
) where {Alg<:AbstractBoundary}
    bulk = state.bulk
    new_alg = similarboundary(Alg, state.alg)
    new_state = new_alg(bulk)
    return new_state
end
