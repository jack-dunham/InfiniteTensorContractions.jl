abstract type AbstractBoundary end
abstract type AbstractBoundaryAlgorithm end
abstract type AbstractBoundaryState{B<:AbstractBoundary} end

@with_kw struct BoundaryAlgorithm{B<:AbstractBoundary,S<:IndexSpace} <:
                AbstractBoundaryAlgorithm
    alg::Type{B}
    bondspace::S
    verbosity::Int = 0
    maxiter::Int = 100
    tol::Float64 = 1e-12
end

@doc raw"""
    BoundaryState{Alg<:AbstractBoundary} <: AbstractBoundaryState{Alg}

A struct representing the state of boundary algorithm of type `Alg`. The paramater `Alg`
can be one of `VUMPS`, `CTMRG`, `FPCM`, `FPCM_CTMRG`, or a user-defined algorithm. 

# Fields
- `data::Alg`: the tensors that compose the boundary, in addition to algorithm specific 
    data
- `mpo::InfMPO`: the matrix product operator whos boundary tensors are stored in `data`
- `initial::Alg`: the tensors used as the starting point of the algorithm
- `info::ConvergenceInfo`: information about the covergence progress of the algorithm
- `param::BoundaryParameters`: the paramaters used in the algorithm
"""
struct BoundaryState{B} <: AbstractBoundaryState{B}
    initial::B
    mpo::InfiniteMPO
    alg::BoundaryAlgorithm{B}
    tensors::B
    info::ConvergenceInfo
end

@doc raw"""
Initilise the tensors compatible with state or tensors `T` for use in boundary algorithm
`alg`. 
"""
function inittensors(f, T, alg::BoundaryAlgorithm) end

# @doc raw"""
# Initilise a new `alg` boundary algorithm state for contracting the infinite lattice
# generated by `T` using boundary tensors generated from the function `f`. The callable 
# `f` should be a callable compatible with the `TensorMap` object. Alternatively, initialise 
# a new algorithm state with initial boundary given by `B`.
# """
# function initstate(f, T, alg::BoundaryAlgorithm)
#     return boundary = inittensors(f, T, alg)
# end

(alg::BoundaryAlgorithm)(M) = alg(rand, M)
function (alg::BoundaryAlgorithm)(f, M)
    boundary = inittensors(f, M, alg)
    return BoundaryState(boundary, M)
end
(alg::BoundaryAlgorithm)(B, M) = BoundaryState(B, M, alg, B, ConvergenceInfo())

function calculate!(::BoundaryState) end
calculate(b::BoundaryState) = calculate!(deepcopy(b))

include("vumps/vumps.jl")
