var documenterSearchIndex = {"docs":
[{"location":"_index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/#Methods","page":"Library","title":"Methods","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"initialize\ncalculate!\ncontract","category":"page"},{"location":"library/#InfiniteTensorContractions.initialize","page":"Library","title":"InfiniteTensorContractions.initialize","text":"initialize(network::AbstractNetwork, alg::AbstractContractionAlgorithm; kwargs...)\ninitialize(network::AbstractNetwork, alg::AbstractContractionAlgorithm, initial_tensors::AbstractContractionTensors; kwargs...)\n\nInitialize an algorithm state to contract network of tensors network using algorithm alg. The keyword argument store_initial determines whether or not the initial state of the contraction tensors is copied and stored in the field initial_tensors of the returned AbstractContractionState object.\n\nArguments\n\nnetwork::AbstractNetwork: the unitcell of tensors to be contracted\nalg::AbstractContractionAlgorithm: the algorithm to contract network with\ninitial_tensors::AbstractContractionTensors: initial tensors to use (optional)\n\nKeywords\n\nstore_initial::Bool = true: perform a deep copy of the initial tensors\noutfile::String = \"outfile.jld2\": file to write data into\nprestep::Function = identity: function to run before every algorithm step\npoststep::Function = identity: function to run after every algorithm step\n\nReturns\n\nAbstractContractionState{Alg,...}: algorithmic state corresponding to the supplied tensors and parameters\n\n\n\n\n\n","category":"function"},{"location":"library/#InfiniteTensorContractions.calculate!","page":"Library","title":"InfiniteTensorContractions.calculate!","text":"calculate!(alg_state::AbstractContractionState)\n\nCalculate the contraction tensors required to contract alg_state.network using alg_state.alg. Returns mutated alg_state. Use calculate for a non-mutating version of the same function.\n\n\n\n\n\n","category":"function"},{"location":"library/#Algorithms","page":"Library","title":"Algorithms","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"VUMPS\nCTMRG","category":"page"},{"location":"library/#InfiniteTensorContractions.VUMPS","page":"Library","title":"InfiniteTensorContractions.VUMPS","text":"VUMPS <: AbstractBoundaryAlgorithm\n\nStores the parameters for the variational uniform matrix product state (VUMPS)  boundary algorithm. \n\nFields\n\nbonddim::Int: the bond dimension of the boundary\nmaxiter::Int = 100: maximum number of iterations\ntol::Float64 = 1e-12: convergence tolerance\nverbose::Bool = true: when true, will print algorithm convergence progress\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteTensorContractions.CTMRG","page":"Library","title":"InfiniteTensorContractions.CTMRG","text":"CTMRG{SVD<:OrthogonalFactorizationAlgorithm}\n\nFields\n\nbonddim::Int: the bond dimension of the boundary\nmaxiter::Int = 100: maximum number of iterations\ntol::Float64 = 1e-12: convergence tolerance\nverbose::Bool = true: when true, will print algorithm convergence progress\nptol::Float64 = 1e-7: tolerance used in the pseudoinverse\nsvd_alg::SVD = TensorKit.SVD(): algorithm used for the SVD. Either TensorKit.SVD() or TensorKit.SDD()\n\n\n\n\n\n","category":"type"},{"location":"#InfiniteTensorContractions.jl","page":"Home","title":"InfiniteTensorContractions.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A package for performing contractions of infinite two-dimensional tensor networks.","category":"page"}]
}
